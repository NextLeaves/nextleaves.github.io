<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	 <link rel="shortcut icon" href="/img/logo_miccall.png">
	
			
    <title>
    Hexo
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">NextLeaves</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/designpattern/">designpattern</a></li><li><a class="category-link" href="/categories/git/">git</a></li><li><a class="category-link" href="/categories/program/">program</a></li><li><a class="category-link" href="/categories/structure/">structure</a></li><li><a class="category-link" href="/categories/unity3d/">unity3d</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/NextLeaves" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://i.imgur.com/iI24evE.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >cpt 4 Object And Type</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="第三章-对象与类型"><a href="#第三章-对象与类型" class="headerlink" title="第三章 对象与类型"></a>第三章 对象与类型</h1><ul>
<li>Wrote : 2017-11-28 23:13:00</li>
<li><p>Name  : NextLeaves</p>
</li>
<li><p>类</p>
</li>
<li>结构</li>
<li>匿名类型</li>
<li>按值和按引用</li>
<li>可空类型</li>
<li>枚举</li>
<li>部分类</li>
<li>扩展方法</li>
<li>Object类</li>
</ul>
<hr>
<h2 id="3-1-创建及使用类"><a href="#3-1-创建及使用类" class="headerlink" title="3.1 创建及使用类"></a>3.1 创建及使用类</h2><ul>
<li>讲述之前学习的是构成类的一些元素，现在组合在一起，组成一个叫完成的类</li>
<li>预先说明下一张的内容：继承以及继承的特性</li>
<li>若已经理解类的其中特性的原理；比如：构造函数、属性等，下面就是针对于C#来进行讲解</li>
</ul>
<hr>
<h2 id="3-2-类和结构"><a href="#3-2-类和结构" class="headerlink" title="3.2 类和结构"></a>3.2 类和结构</h2><ul>
<li>二者是创建的模板，都包含数据，同时提供对数据的处理和访问的方法<ul>
<li>类：数据具有固定的字段内容</li>
<li>结构：较小的数据类型可以提高性能</li>
<li>（<strong>类</strong> 是引用类型，常具体数据分配在heap上、只是引用分配在stack上；<strong>结构</strong> 是值类型，分配在stack上；同时<strong>不支持继承</strong>）</li>
<li>（类 类型按照引用传递；结构 类型按照值传递）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><ul>
<li>类包含<strong>实例成员</strong>和<strong>静态成员</strong><ul>
<li>静态成员属于类：静态的字段值是一样的，且用static修饰</li>
<li>实例成员属于对象：实例的字段值可以不同</li>
</ul>
</li>
<li>成员的种类：<ul>
<li>字段</li>
<li>常量</li>
<li>属性：可以从客户端访问的函数组</li>
<li>方法</li>
<li>构造函数：用于初始化字段值</li>
<li>索引器：允许通过下标访问数组</li>
<li>运算符：数据的加法操作或者减法操作等；后续还会涉及运算符重载</li>
<li>事件：是类中的一个成员，可以通过此包含事件对象的状态发生改变时，通知关注的对象，对应的做出变化的方式</li>
<li>析构函数（又名：终结器）：CLR检测不再需要的对象，将进行垃圾回收机制（GC）；不可预测什么时候进行回收</li>
<li>类型：存储其他<strong>类</strong>类型，或者其他<strong>结构</strong>类型；嵌套<strong>类</strong>类型</li>
</ul>
</li>
</ul>
<h3 id="3-3-1-字段"><a href="#3-3-1-字段" class="headerlink" title="3.3.1 字段"></a>3.3.1 字段</h3><ul>
<li>具体讲解字段（Custom类）</li>
<li>常量用const修饰</li>
<li><strong>一般不要用public修饰字段</strong>：修改公共成员变量字段的值，使每个调用此字段的对象也需要进行更改。例如：10个人用字段的值，若有一个人改变了，则全部都需要改变；则可以减少，或者不用编译</li>
</ul>
<h3 id="3-3-2-属性"><a href="#3-3-2-属性" class="headerlink" title="3.3.2 属性"></a>3.3.2 属性</h3><ul>
<li>命名法则：<ul>
<li>私有字段使用小写字母命名；公有属性使用大写字母命名；利用Pascal命名法</li>
<li>若存在等价的私有字段，则使用camel命名法</li>
<li>现在微软使用下划线，作为区分字段的方法</li>
</ul>
</li>
<li>自动实现的属性：不用生成私有字段<ul>
<li>简单的创建字段的替代品，的快捷方式</li>
<li>可以利用属性初始化器 进行初始化</li>
</ul>
</li>
<li>属性的访问修饰符：<ul>
<li>必须有一个具有属性的访问级别（简单说有一个必须是public，但不需要public来修饰）</li>
<li>只有get访问器的属性；可以实现只读属性</li>
<li>只有get访问器的自动属性；是C#6.0所具有的特性</li>
</ul>
</li>
<li>担心过多的编码会导致性能的下降：<ol>
<li>C#代码会编译为IL；然后在JIT的运行下，编译为本地代码运行；JIT可以在合适的时候，随意的内联代码（内联代码来代替函数调用）</li>
<li>若一个代码实现函数或者属性只是通过一个函数的，那么它肯定是内联的函数</li>
<li>MethodImpl属性，可以控制函数是否内联的控制（了解为主）</li>
</ol>
</li>
</ul>
<p>`</p>
<pre><code>//属性初始化器
public string Name{get;set;}=&quot;Xiaoming&quot;;
</code></pre><h3 id="3-3-3-方法"><a href="#3-3-3-方法" class="headerlink" title="3.3.3 方法"></a>3.3.3 方法</h3><ul>
<li>正式的C#属于区分函数和方法；数据成员包含：字段、常量、事件；其他成员为非数据成员</li>
<li>方法的声明（略）</li>
<li>表达式体方法：利用=&gt;进行的函数书写，且函数语句只有一条的情况下</li>
<li>调用函数（略）</li>
<li>方法的重载：<ol>
<li>参数个数不同</li>
<li>参数类型不同</li>
</ol>
</li>
<li>命名的参数：在调用函数的时候，可以书写参数名再赋值；真正的目的是为了<strong>可选参数</strong></li>
</ul>
<p>`</p>
<pre><code>//命名的参数：
public string Message(string name,int age,int high);

//调用时：
Message(name:&quot;Xiaoming&quot;,age:20,high:180);
</code></pre><ul>
<li>可选参数：<ol>
<li>必须是拥有默认值</li>
<li>必须是非默认值后面，即声明的时候在函数最右边</li>
</ol>
</li>
<li>注意：<ol>
<li>若默认值修改且没有重新编译，则调用旧的默认值；所以应该使用不会改变的默认值；否则就重新编译程序集</li>
<li>可选参数的版本控制问题<ul>
<li>一个问题：添加可选参数的数目</li>
<li>二个问题：修改可选参数的默认值</li>
<li>修改很简单，但是编译器会重新填充整个函数，之前的函数体就会失效</li>
</ul>
</li>
</ol>
</li>
<li>个数可变的参数：params修饰数组</li>
</ul>
<p>`</p>
<pre><code>//个数可变的参数：
public int Sum(params int[] number);
//若想使用任何类型的参数
public void AnyParametersOfArguments(params object[] object);
//若与其他多个参数使用，则paras只能使用一次，且是声明的最后一个
public void GetMessage(string name,params int[] ages);
</code></pre><h3 id="3-3-4-构造函数"><a href="#3-3-4-构造函数" class="headerlink" title="3.3.4 构造函数"></a>3.3.4 构造函数</h3><ul>
<li>默认构造函数的介绍：<ul>
<li>引用类型：默认为空</li>
<li>值类型：默认为0</li>
<li>bool类型：默认为false</li>
</ul>
</li>
<li>若自定义一个构造函数，则默认构造函数不存在</li>
<li>可以通过访问修饰符，修饰构造函数，可以让不相关的类型无法访问<ul>
<li>单例模式的实现</li>
<li>不实例化对象，只使用静态方法</li>
</ul>
</li>
<li>在构造函数中调用其他构造函数</li>
</ul>
<p>`</p>
<pre><code>//在构造函数中调用其他构造函数
public Custom(string expresstion):this(string expresstion,int age)
{}
</code></pre><ul>
<li>静态构造函数：只会执行一次；类中存在静态的字段和属性，用于在使用类之前，初始化静态字段和属性<ul>
<li>不因控制静态构造函数在什么位置执行，比如加载程序集的时候执行，所以不应该吧加载程序集的代码写在静态构造函数内</li>
<li>不因控制不同类的静态构造函数的顺序，所以不要加以控制</li>
<li>注意：静态构造函数没有访问修饰符；其他C#代码不显式调用，是通过.NET运行库进行调用</li>
<li>不能带任何参数，且一个类只有一个静态构造函数</li>
<li>静态构造函数，只能访问了类的静态成员，不能访问对象成员</li>
<li>可以在同一个类中书写：静态构造函数和无参数的实例构造函数，不冲突</li>
<li>如果有多个类具有静态构造函数，则不能确定类的相互影响，来控制类的静态构造函数的调用顺序</li>
<li>若静态字段或者属性有默认值，则在静态构造函数中进行初始化</li>
</ul>
</li>
</ul>
<p>`</p>
<pre><code>//静态构造函数示例：
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(UserPreferences.BackColor);
        }
    }

    enum Color
    {
        Red,
        Green
    }

    static class UserPreferences
    {
        public static Color BackColor { get; }

        static UserPreferences()
        {
            DateTime now = new DateTime();
            if (now.DayOfWeek == DayOfWeek.Saturday || now.DayOfWeek == DayOfWeek.Sunday)
            {
                BackColor = Color.Red;
            }
            else
            {
                BackColor = Color.Green;
            }
        }
    }
}
</code></pre><h3 id="3-3-5-只读成员"><a href="#3-3-5-只读成员" class="headerlink" title="3.3.5 只读成员"></a>3.3.5 只读成员</h3><ul>
<li>若不希望在后续修改字段的值，可以使用readonly修饰</li>
</ul>
<h3 id="3-3-6-只读属性"><a href="#3-3-6-只读属性" class="headerlink" title="3.3.6 只读属性"></a>3.3.6 只读属性</h3><ul>
<li>readonly与const的区别：<ol>
<li>前者在构造函数中初始化，可以作为对象成员，也可以是类成员（用static修饰）</li>
<li>后者在调用的时候，编译器会直接替换为值（inline的形式）</li>
</ol>
</li>
<li>只读属性：<ul>
<li>省略set访问器</li>
<li>只写属性，省略get访问器，但是着通常不建议，会导致客户端作者迷茫；最好是通过方法来撰写</li>
</ul>
</li>
<li>自动实现的只读属性：<ul>
<li>依然可以在构造函数中进行初始化</li>
<li>也可以使用该自动初始化器来初始化</li>
</ul>
</li>
<li>表达式体属性：<ul>
<li>可以直接get访问器的方式，输出信息</li>
</ul>
</li>
<li>不可变的类型：<ul>
<li>一个类若包含有可以改变的类型，则为可变类型；若一个类全部有readonly等修饰，则只能在构造函数中初始化，则成为不可变类型</li>
<li>这对于多线程有重要意义：因为多个线程进行访问，因为内容是不变的，所以就不需要同步</li>
<li>举例：String类，没有定义任何改变其内容的成员，比如：ToUpper，总是返回一个新的字符串，传递到字符串的原始字符串不变</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-4-匿名类型"><a href="#3-4-匿名类型" class="headerlink" title="3.4 匿名类型"></a>3.4 匿名类型</h2><ul>
<li>匿名类型：表示隐式类型化的变量；只是继承自object且没有类型名的类</li>
<li>所有属性匹配，则为同一个类型，可以进行赋值操作</li>
<li>不应使用反射来获取匿名类型对应的类型名</li>
</ul>
<hr>
<blockquote>
<p>回顾上一节内容：</p>
</blockquote>
<ol>
<li>封装数据</li>
<li>存储的位置</li>
<li>数据的生存期</li>
</ol>
<hr>
<h2 id="3-5-结构"><a href="#3-5-结构" class="headerlink" title="3.5 结构"></a>3.5 结构</h2><ul>
<li>使用类，可以拓展很多方面；但是有时候只需要小的数据类型；在heap的优化，可以减少性能损失，但是更好的方法是使用结构，来提高性能</li>
<li>存储简单的数据类型，进行简单的运算操作</li>
<li>结构不支持继承</li>
<li>若没有构造函数，则有一个默认构造函数</li>
<li><strong>使用结构，可以指定字段如何在内存中布局</strong></li>
</ul>
<p>`</p>
<pre><code>public struct Dimension
{
    public double _high;
    public double _width;
    public double Square(double high=_high,double width=_width)=&gt;high*width;
}
</code></pre><h3 id="3-5-1-结构是值类型"><a href="#3-5-1-结构是值类型" class="headerlink" title="3.5.1 结构是值类型"></a>3.5.1 结构是值类型</h3><ul>
<li>虽然结构是值类型，但是当做类的方式来处理；new只是调用构造函数，而不分配内存</li>
<li>结构类型必须初始化后才能使用</li>
<li>优点：<ul>
<li>分配快，在stack中，inline</li>
<li>释放快，不需要等待垃圾回收</li>
</ul>
</li>
<li>缺点：作为参数进行传递的时候（结构体要用于小的数据存储）<ul>
<li>使用ref引用调用，减少性能的损失</li>
<li>若单纯的调用，则会进行值的复制</li>
</ul>
</li>
<li>结构和继承：虽然结构无法继承，但是结构是继承下来的类型<ul>
<li>System.Object-&gt;System.ValueType-&gt;Struct</li>
<li>意味着Struct可以修改Object的方法，如：ToString()</li>
</ul>
</li>
<li>结构的构造函数（C#6）：可以在默认构造函数中，初始化字段值；在C#6之前，为实现此功能</li>
</ul>
<h3 id="3-5-2-按值和按引用传递参数"><a href="#3-5-2-按值和按引用传递参数" class="headerlink" title="3.5.2 按值和按引用传递参数"></a>3.5.2 按值和按引用传递参数</h3><ul>
<li>值是复制，引用传递实际的参数</li>
<li>ref参数：让值类型传递引用的方式</li>
<li>out参数：可以返回多个值</li>
</ul>
<h3 id="3-5-3-可空类型"><a href="#3-5-3-可空类型" class="headerlink" title="3.5.3 可空类型"></a>3.5.3 可空类型</h3><ul>
<li>引用类型的类型可以为空，但是值类型的变量不能为空</li>
<li>问题：数据库和XML的值类型可以为空，导致出现问题所在</li>
<li>处理方式：<ul>
<li>（java处理方式）使用隐射到数据库类型的类，来处理值类型为空的操作；需要进行类型的分配和垃圾处理机制</li>
<li>（C#处理方式）使用可空类型，格式：int？，唯一的开销为bool类型，来判断是否为空</li>
</ul>
</li>
<li>可空类型的属性：HasValue：判断是否有值；再使用Value来获取值</li>
</ul>
<h3 id="3-5-4-枚举"><a href="#3-5-4-枚举" class="headerlink" title="3.5.4 枚举"></a>3.5.4 枚举</h3><ul>
<li>可以限制枚举的类型；既可以强制转换为枚举，也可以枚举强制转换值</li>
<li>使用[Flags]特性：<ul>
<li>实现多种符合的状态（位域）</li>
<li>使用16进制来标志，设置不同的位</li>
<li>通过与运算，把值转换为二进制，然后进行01的判断</li>
</ul>
</li>
</ul>
<h3 id="3-5-5-部分类"><a href="#3-5-5-部分类" class="headerlink" title="3.5.5 部分类"></a>3.5.5 部分类</h3><ul>
<li>partial关键字：允许把类、结构、方法、结构放在其他文件中</li>
<li>应用于所有类的修饰：<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
<li>sealed</li>
<li>new</li>
<li>internal</li>
<li>abstract</li>
<li>一般约束</li>
</ul>
</li>
<li>部分类，可以包含部分方法：在一个部分类中声明方法；在另一个部分类中实现方法<ul>
<li>必须是void返回值类型，因为在没有实现部分方法时，无法删除未实现的部分方法</li>
</ul>
</li>
</ul>
<h3 id="3-5-6-扩展方法"><a href="#3-5-6-扩展方法" class="headerlink" title="3.5.6 扩展方法"></a>3.5.6 扩展方法</h3><ul>
<li>给类添加方法的好办法是：继承；还有一个方法就是扩展方法</li>
<li>例子：假如希望扩展String类的方法，计算字符串的中单词的数目</li>
<li>格式：<ol>
<li>静态的类进行扩展：Public Static class StringExtension{}</li>
<li>函数参数为this修饰扩展的类型</li>
<li>即使是<strong>静态的函数</strong>，但是同样通过<strong>对象来书写</strong>；编译器会修改为静态访问方式，用于区分，扩展方法</li>
</ol>
</li>
<li>如果在扩展函数的原函数中有同名函数，则优先调用原函数</li>
<li>且扩展函数，需要包含在相对应的原函数所拥有的命名空间内</li>
<li>Linq(Language Integrated Query)语法，运用很多扩展方法的写法</li>
</ul>
<p>`</p>
<pre><code>public static class StringExtension
    {
        public static int WordsofCount(this string s) =&gt; s.Split(&quot; &quot;).Length;
    }

    class A
    {
        public string x;


    }

    static class AExtension
    {
        public static void SendMessage(this A a) =&gt; Console.WriteLine(a.x);
    }
</code></pre><h2 id="3-6-Object类"><a href="#3-6-Object类" class="headerlink" title="3.6 Object类"></a>3.6 Object类</h2><ul>
<li>所有类的继承者</li>
<li>意义在：可以访问Object类定义的公有和受保护的成员方法<ul>
<li>ToString（）:获取对象的类型（字符串形式）</li>
<li>GetHashCode（）：若对象放在名为散列表或者字典的数据结构中时，提取hash值</li>
<li>Equals（）和ReferenceEquals（）<ul>
<li>前者：</li>
<li>后者：</li>
</ul>
</li>
<li>Finalize（）：对象作为垃圾的时候调用</li>
<li>GetType（）：获取对象所属的类型</li>
<li>MemberwiseClone（）：返回值，对副本的引用；对于值类型，就是装箱的引用</li>
</ul>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/11/28/Object/Books/Program/PerfessionalProgram/cpt3 _ObjectAndType/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2017/11/28/Object/Books/Program/PerfessionalProgram/cpt3 _ObjectAndType/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
